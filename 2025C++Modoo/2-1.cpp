#include <iostream>

int function()
{
	int a = 3;
	return a;
}

int& function_in() {
	int a = 4;
	return a;
}

int& function_out(int& a)
{
	a = 4;
	return a;
}

int main()
{
	//----------------------------------------------------------------------------------------------------------------------------------------
	int a = 3;
	int& another_a = a;									// 참조자(reference)

	another_a = 5;
	std::cout << "a : " << a << std::endl;
	std::cout << "another_a : " << another_a << std::endl;

	//----------------------------------------------------------------------------------------------------------------------------------------
	int b[3] = { 1,2,3 };
	int(&ref)[3] = b;									// 배열의 reference 가능

	for (int i = 0; i < 3; ++i)
	{
		std::cout << b[i] << " ";
	}
	std::cout << std::endl;

	//----------------------------------------------------------------------------------------------------------------------------------------
	int c = function_in();								// 참조하려던 a가 사라진 레퍼런스를 댕글링 레퍼런스라고 한다.
	c = 3;												// 레퍼런스를 리턴하는 함수에서 사라진 지역변수의 레퍼런스를 리턴하지 않도록 해야한다.

	//----------------------------------------------------------------------------------------------------------------------------------------
	int d = 3;											// 외부 변수의 레퍼런스를 리턴
	int e = function_out(d);							// 결과에서 알 수 있듯이 인자로 받은 레퍼런스를 그대로 리턴

	std::cout << d << ", " << e << std::endl;

	//----------------------------------------------------------------------------------------------------------------------------------------
	int& f = function();								// 이렇게 하면 리턴값이 바로 사라져서 댕글링 래퍼런스가 된다.
	const int& f = function();							// 중요한 예외 규칙!!!	const로 받았더니 빨간줄이 사라짐
														// 상수 레퍼런스로 리턴값을 받게 되면 해당 리턴값의 생명이 연장된다.

	return 0;
}

//	레퍼런스는 포인터와 유사하지만 중요한 차이점이 있다.
// 
//	1. 레퍼런스는 반드시 처음에 누구의 별명이 될 것인지 지정해야 한다.
//	ex) int* p; (O) 가능
//		int& r; (X) 불가능
//
//	2. 레퍼런스가 한 번 별명이 되면 절대로 다른 이의 별명이 될 수 없다.
//	ex) int a = 10;
//		int& another_a = a;
//
//		int b = 3;
//		another_a = b;	-> 이 문장은 결국 b의 값을 a에 대입하는 것과 같다.
//	
//	3. 레퍼런스는 메모리 상에 존재하지 않을 수도 있다.
//	ex)	int a = 10;
//		int& another_a = a; -> another_a는 메모리 상에 존재 X
//
//	-> 레퍼런스는 객체가 아니다. 수명·복사·대입 같은 개념도 없다.
//	
// 
//
// 
//	
//	생각해보기
//	레퍼런스가 메모리 상에 반드시 존재해야 하는 경우는 어떤 경우가 있을까요?
// 	
//	1. 클래스, 구조체의 데이터 멤버			-> 각 객체가 다른 대상을 참조할 수 있으므로, 객체마다 '무엇을 가리키는지' 기록해야 함
//		struct S { int& r; };
// 
//	2. 전역, 정적 레퍼런스 변수				-> 프로그램 전체 수명 동안 주소를 보존해야 하므로
//		int& g = some;
//	
//	3. 참조 캡처 람다 객체					-> 람다 객체가 복사, 이동될 수 있으며 객체마다 캡처한 변수의 위치를 알고 있어야 함
//		auto L = [&x] { ... };
//
//	4. 배열 원소처럼 저장해야 하는 경우
//		std::array<int&, 3> 내부			-> 컨테이너가 원소를 연속 메모리에 배치해야 하므로, 각 레퍼런스를 값으로 저장
//
//	그리고 메모리 상에 존재할 필요가 없는 경우는 또 어떤 경우가 있을 까요?
//	
//	1. 함수 매개변수						-> 호출 규약 상 이미 "가리키는 주소" 가 레지스터(혹은 스택 슬롯)에 전달됨, 함수 몸체 안에서 별도 이름이 하나 더 생기는 것뿐
//		void f(int& x)
//
//	2. 지역 레퍼런스 변수					-> ref 는 그 범위에서 y 와 완전히 같은 애칭, 별도 주소를 만들지 않아도 모든 연산을 y 에 바로 매핑 가능
//		int y = 0; int& ref = y;
//
//	3. const T& 로 받은 임시 객체 바인딩	-> 임시(T)를 어딘가에 저장해야 하는 건 맞지만, 레퍼런스 자체는 그 임시의 주소를 가리킬 뿐 별도 저장 필요 없음
// 
//	4. return T&							-> 호출자에게 전달할 때 원본 객체 주소를 그대로 레지스터/스택으로 반환
// 
//	5. 전부 인라인, 최적화되는 코드
//